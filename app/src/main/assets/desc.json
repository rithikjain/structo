{
  "binary_search": {
    "Binary Search": "Binary Search is a search algorithm that finds the position of a target value within a sorted array. It works by comparing the target value to the middle element of the array; if they are unequal, the lower or upper half of the array is eliminated depending on the result and the search is repeated in the remaining subarray until it is successful.",
    "Applications": [
      "Finding values in a sorted collection",
      "Traversing binary search trees"
    ],
    "Complexity": {
      "Time": "worst O(log(N)), best O(1), average O(log(N))",
      "Space": "worst O(log(N)) - recursive, O(1) - iterative"
    }
  },
  "linear_search": {
    "Linear Search": "Linear search or sequential search is a method for finding a target value within a list. It sequentially checks each element of the list for the target value until a match is found or until all the elements have been searched.",
    "Applications": [
      "Finding values in an unordered list"
    ],
    "Complexity": {
      "Time": "worst O(N), best O(1), average O(N)",
      "Space": "worst O(1) - iterative"
    }
  },
  "linked_list": {
    "Singly linked list": "A Linked List is a linear collection of data elements, called nodes, each pointing to the next node by means of a pointer. It is a data structure consisting of a group of nodes which together represent a sequence. Under the simplest form, each node is composed of data and a reference (in other words, a link) to the next node in the sequence. ",
    "Complexity": {
      "Time": "<br>Search: worst O(n), average O(n)<br>   Access: worst O(n), average O(n) <br>   Deletion: worst O(1), average O(1) <br>  Insertion : worst O(1), average O(1) <br> ",
      "Space": "<br>worst O(n)"
    }
  },
  "stack": {
    "Stack": "A stack is an abstract data type that serves as a collection of elements, with two principal operations: push, which adds an element to the collection, and pop, which removes the most recently added element that was not yet removed. The order in which elements come off a stack gives rise to its alternative name, LIFO (for last in, first out). Additionally, a peek operation may give access to the top without modifying the stack.",
    "Complexity": {
      "Time": "<br>Search: worst O(n), average O(n)<br>   Access: worst O(n), average O(n) <br>   Deletion: worst O(1), average O(1) <br>  Insertion : worst O(1), average O(1) <br> ",
      "Space": "<br>worst O(n)"
    }
  },
  "bfs": {
    "BFS": "Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key') and explores the neighbor nodes first, before moving to the next level neighbors.",
    "Applications": [
      "Copying garbage collection, Cheney's algorithm",
      "Finding the shortest path between two nodes u and v, with path length measured by number of edges (an advantage over depth-first search)",
      "Testing a graph for bipartiteness",
      "(Reverse) Cuthill–McKee mesh numbering",
      "Ford–Fulkerson method for computing the maximum flow in a flow network",
      "Serialization/Deserialization of a binary tree vs serialization in sorted order, allows the tree to be re-constructed in an efficient manner.",
      "Construction of the failure function of the Aho-Corasick pattern matcher."
    ],
    "Complexity": {
      "Time": "worst O(|E|)",
      "Space": "worst O(|V|)"
    }
  },
  "dfs": {
    "DFS": "Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. One starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking.",
    "Applications": [
      "Finding connected components.",
      "Topological sorting.",
      "Finding 2-(edge or vertex)-connected components.",
      "Finding 3-(edge or vertex)-connected components.",
      "Finding the bridges of a graph.",
      "Generating words in order to plot the Limit Set of a Group.",
      "Finding strongly connected components.",
      "Planarity testing",
      "Solving puzzles with only one solution, such as mazes. (DFS can be adapted to find all solutions to a maze by only including nodes on the current path in the visited set.)",
      "Maze generation may use a randomized depth-first search.",
      "Finding biconnectivity in graphs."
    ],
    "Complexity": {
      "Time": "worst O(|E|)",
      "Space": "worst O(|V|)"
    }
  }
}